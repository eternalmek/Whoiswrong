-- Profiles table for user settings and public info
create table if not exists public.profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),
  username text unique,
  display_name text,
  avatar_url text,
  bio text,
  country text,
  is_public_profile boolean default true,
  dark_mode_preference boolean default false,
  allow_friend_requests boolean default true,
  show_debates_on_wall boolean default true,
  allow_notifications boolean default true,
  last_friend_request_at timestamptz,
  notification_preferences jsonb default '{}'::jsonb
);

-- RLS setup for profiles
alter table public.profiles enable row level security;

create policy "Public profiles visible" on public.profiles
  for select using (is_public_profile = true);

create policy "Users can view own profile" on public.profiles
  for select using (auth.uid() = id);

create policy "Users can update own profile" on public.profiles
  for update using (auth.uid() = id);

create policy "Users can insert own profile" on public.profiles
  for insert with check (auth.uid() = id);

-- Trigger to keep updated_at fresh
create or replace function public.touch_profiles() returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

create trigger trigger_profiles_updated_at
  before update on public.profiles
  for each row
  execute function public.touch_profiles();

-- Auto-create profile after signup
create or replace function public.handle_new_user() returns trigger as $$
begin
  insert into public.profiles (id, display_name, username)
  values (new.id, coalesce(split_part(new.email, '@', 1), 'New User'), null)
  on conflict (id) do nothing;
  return new;
end;
$$ language plpgsql security definer set search_path = public;

create trigger on_auth_user_created
  after insert on auth.users
  for each row execute function public.handle_new_user();

-- Friendships table
create table if not exists public.friendships (
  id bigint generated by default as identity primary key,
  requester_id uuid not null references auth.users(id) on delete cascade,
  receiver_id uuid not null references auth.users(id) on delete cascade,
  status text not null check (status in ('pending','accepted','blocked','cancelled','declined','removed')),
  action_user_id uuid references auth.users(id),
  created_at timestamptz default now(),
  updated_at timestamptz default now(),
  constraint friendships_requester_receiver_unique unique (requester_id, receiver_id)
);

create index if not exists idx_friendships_receiver_status on public.friendships (receiver_id, status);
create index if not exists idx_friendships_requester_status on public.friendships (requester_id, status);

-- RLS for friendships
alter table public.friendships enable row level security;

create policy "Friendship visibility for participants" on public.friendships
  for select using (auth.uid() = requester_id or auth.uid() = receiver_id);

create policy "Create friendship request" on public.friendships
  for insert with check (auth.uid() = requester_id and requester_id <> receiver_id);

create policy "Requester can manage their requests" on public.friendships
  for update using (auth.uid() = requester_id) with check (auth.uid() = requester_id);

create policy "Receiver can manage incoming requests" on public.friendships
  for update using (auth.uid() = receiver_id) with check (auth.uid() = receiver_id);

-- Keep updated_at in sync
create or replace function public.touch_friendships() returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

create trigger trigger_friendships_updated_at
  before update on public.friendships
  for each row execute function public.touch_friendships();
